#include "GLHeaders.hpp"
#include "GLShaderLoader.hpp"
#include "Camera.hpp"
#include "ModelData.hpp"
#include "Renderer.hpp"

#include "glm/vec3.hpp"
#include "glm/vec4.hpp"
#include "glm/mat4x4.hpp"
#include "glm/gtc/matrix_transform.hpp"
#include "glm/gtx/rotate_vector.hpp"

#define TAU (6.283185307179586f)
#define DEG2RAD(x) ((x) / 360.0f * TAU)

#define SKY_DIR (glm::vec3(0, 1, 0))
#define FORWARD_DIR (glm::vec3(0, 0, 1))
#define ORIGIN  (glm::vec3(0))

static ModelData* terrainModel;
static ModelData* building;

static Renderer* renderer;
static Camera* cam1;

static float screenWidth = 800;
static float screenHeight = 600;

static long prevTime = 0;

// A simple structure for storing relevant information required for mouse control
static struct MouseHandler {
    MouseHandler() : x(0), y(0), prevX(0), prevY(0), isDown(false) {}
    int x, y;
    int prevX, prevY;
    bool isDown;
    inline int dx() { return x - prevX; }
    inline int dy() { return y - prevY; }
    inline void update(int nx, int ny) { prevX = x; prevY = y; x = nx; y = ny; }
} mouseHandler;


// Generates a square terrain with the specified texture loaded from a file
RawModelData genTerrainModel(const std::string& terrainTexture) {
    RawModelData data;
    RawModelData::Shape shape;

    shape.vertices.reserve(4);
    shape.vertices.push_back(glm::vec3(-1, -1, 1));
    shape.vertices.push_back(glm::vec3(-1, -1, -1));
    shape.vertices.push_back(glm::vec3(1, -1, -1));
    shape.vertices.push_back(glm::vec3(1, -1, 1));

    shape.normals.reserve(4);
    for (size_t i = 0; i < 4; ++i) {
        shape.normals.push_back(glm::vec3(0, 1, 0));
    }

    shape.texCoords.reserve(4);
    shape.texCoords.push_back(glm::vec2(0, 1));
    shape.texCoords.push_back(glm::vec2(0, 0));
    shape.texCoords.push_back(glm::vec2(1, 0));
    shape.texCoords.push_back(glm::vec2(1, 1));

    shape.indices.push_back(0);
    shape.indices.push_back(1);
    shape.indices.push_back(2);
    shape.indices.push_back(0);
    shape.indices.push_back(2);
    shape.indices.push_back(3);

    shape.material.ambient = glm::vec3(0.3f);
    shape.material.diffuse = glm::vec3(1.0f);
    shape.material.specular = glm::vec3(0.0f);
    shape.material.shininess = 0.0f;
    shape.material.dissolve = 0.0f;

    shape.textureName = terrainTexture;

    data.shapes.push_back(shape);
    return data;
}

// Initialise the program resources
void initResources() {
    GLuint program = initProgram(shaderFromFile("shaders/vshader.glsl", GL_VERTEX_SHADER),
        shaderFromFile("shaders/fshader.glsl", GL_FRAGMENT_SHADER));
    glUseProgram(program);

    cam1 = new Camera(glm::vec3(0.0f, 40.0f, 0.0f));
    cam1->rotate(glm::vec3(-TAU / 4.0f, 0.0f, 0.0f));
    glm::mat4 proj = glm::perspective(DEG2RAD(60.0f), screenWidth / screenHeight, 0.1f, 200.0f);

    renderer = new Renderer(program, proj, cam1);

    building = new ModelData(loadModelData("data/house/House2.obj"), renderer);
    terrainModel = new ModelData(genTerrainModel("data/grassTex.tga"), renderer);
}

// Display callback
void onDisplay() {
    glClearColor(0.7f, 0.8f, 1.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    renderer->drawModel(building, glm::vec3(0, -1, 0), glm::vec3(2));
    renderer->drawModel(building, glm::vec3(32, -1, 0), glm::vec3(2));
    renderer->drawModel(terrainModel, ORIGIN, glm::vec3(40, 1, 40));

    // Swap buffers
    glutSwapBuffers();
}

// Idle callback
void onIdle() {
    long time = glutGet(GLUT_ELAPSED_TIME);
    float dt = static_cast<float>(time - prevTime) / 1000.0f;
    prevTime = time;

    glutPostRedisplay();
}

// Keyboard callback
void keyboard(unsigned char key, int x, int y) {
    switch (key) {
    case 033: exit(EXIT_SUCCESS); break;
    case 'w': cam1->move(glm::vec3(0, 0, 0.2f)); break;
    case 's': cam1->move(glm::vec3(0, 0, -0.2f)); break;
    case 'a': cam1->move(glm::vec3(-0.2f, 0, 0)); break;
    case 'd': cam1->move(glm::vec3(0.2f, 0, 0)); break;
    }
}

// Mouse click callback
void onMouse(int button, int state, int x, int y) {
    mouseHandler.update(x, y);
}

// Mouse motion callback
void onMotion(int x, int y) {
    mouseHandler.update(x, y);
    // Compute the angles generated by the motion of the mouse
    glm::vec3 angles = glm::vec3(TAU * static_cast<float>(-mouseHandler.dy()) / screenHeight,
        TAU * static_cast<float>(-mouseHandler.dx()) / screenWidth, 0.0f);
    cam1->rotate(angles);

    glutPostRedisplay();
}

// Window shape callback
void onReshape(int width, int height) {
    screenWidth = static_cast<float>(width);
    screenHeight = static_cast<float>(height);
    glViewport(0, 0, width, height);

    renderer->proj = glm::perspective(DEG2RAD(60.0f), screenWidth / screenHeight, 0.1f, 200.0f);
}

// Program entry point
int main(int argc, char* argv[]) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH | GLUT_MULTISAMPLE);
    glutInitWindowSize(800, 600);
    glutCreateWindow("Assignment 4");

    glewInit();

    // Enable GL properties
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glCullFace(GL_TRUE);

    // Set up callbacks
    glutDisplayFunc(onDisplay);
    glutIdleFunc(onIdle);
    glutReshapeFunc(onReshape);
    glutKeyboardFunc(keyboard);
    glutMouseFunc(onMouse);
    glutMotionFunc(onMotion);

    initResources();

    glutMainLoop();
    return 0;
}